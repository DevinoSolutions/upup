{"version":3,"sources":["../src/index.node.ts","../src/backend/lib/aws/s3/s3-generate-presigned-url.ts","../src/shared/types.ts","../src/shared/lib/checkFileType.ts","../src/backend/lib/files/file-validate-params.ts","../src/backend/lib/aws/s3/s3-generate-signed-url.ts","../src/backend/lib/aws/aws-generate-signature-headers.ts","../src/backend/lib/aws/s3/s3-update-cors.ts","../src/backend/lib/azure/azure-generate-sas-url.ts","../src/backend/lib/azure/azure-get-temporary-credentials.ts"],"sourcesContent":["export { default as s3GeneratePresignedUrl } from './backend/lib/aws/s3/s3-generate-presigned-url'\nexport { default as s3GenerateSignedUrl } from './backend/lib/aws/s3/s3-generate-signed-url'\nexport { default as azureGenerateSasUrl } from './backend/lib/azure/azure-generate-sas-url'\nexport { UpupProvider } from './shared/types'\n","import { PutObjectCommand, S3Client, _Error } from '@aws-sdk/client-s3'\nimport { getSignedUrl } from '@aws-sdk/s3-request-presigner'\nimport { v4 as uuid } from 'uuid'\nimport {\n    PresignedUrlResponse,\n    UploadError,\n    UploadErrorType,\n} from '../../../../shared/types'\nimport { S3PresignedUrlParams } from '../../../types'\nimport fileValidateParams from '../../files/file-validate-params'\nimport s3GenerateSignedUrl from './s3-generate-signed-url'\nimport s3UpdateCORS from './s3-update-cors'\n\nconst DEFAULT_EXPIRES_IN = 3600\n\nfunction getUploadErrorParams(error: unknown) {\n    const message = (error as _Error)?.Message ?? (error as Error).message\n    const errorType = ((error as _Error)?.Code ??\n        UploadErrorType.PRESIGNED_URL_ERROR) as UploadErrorType\n\n    return { message, errorType }\n}\n\nexport default async function s3GeneratePresignedUrl({\n    fileParams,\n    bucketName: Bucket,\n    s3ClientConfig,\n    expiresIn = DEFAULT_EXPIRES_IN,\n    origin,\n    provider,\n    enableAutoCorsConfig = false,\n}: S3PresignedUrlParams): Promise<PresignedUrlResponse> {\n    const {\n        name: fileName,\n        type: ContentType,\n        size: ContentLength,\n    } = fileParams\n    try {\n        // Validate file params\n        fileValidateParams(fileParams)\n\n        if (enableAutoCorsConfig) {\n            // Configure CORS for request origin\n            await s3UpdateCORS(origin, Bucket, s3ClientConfig, provider)\n        }\n\n        // Create S3 client\n        const client = new S3Client(s3ClientConfig)\n\n        // Generate unique key for the file\n        const Key = `${uuid()}-${fileName}`\n\n        // Create PutObject command\n        const command = new PutObjectCommand({\n            Bucket,\n            Key,\n            ContentType,\n            ContentLength,\n        })\n\n        // Generate presigned URL\n        const uploadUrl = await getSignedUrl(client, command, {\n            expiresIn,\n            signableHeaders: new Set(['content-type', 'content-length']),\n        })\n\n        // Generate public URL (if bucket is public)\n        const publicUrl = await s3GenerateSignedUrl(s3ClientConfig, Key, Bucket)\n\n        return {\n            key: Key,\n            publicUrl,\n            uploadUrl,\n            expiresIn,\n        }\n    } catch (error) {\n        if (error instanceof UploadError) throw error\n\n        const { message, errorType } = getUploadErrorParams(error)\n        throw new UploadError(message, errorType, false, 500)\n    }\n}\n","import { FC } from 'react'\n\nexport enum UploadAdapter {\n    INTERNAL = 'INTERNAL',\n    GOOGLE_DRIVE = 'GOOGLE_DRIVE',\n    ONE_DRIVE = 'ONE_DRIVE',\n    LINK = 'LINK',\n    CAMERA = 'CAMERA',\n    // DROPBOX = 'DROPBOX',\n    // UNSPLASH = 'UNSPLASH',\n    // BOX = 'BOX',\n}\n\nexport type GoogleDriveConfigs = {\n    google_api_key: string\n    google_app_id: string\n    google_client_id: string\n}\n\nexport type OneDriveConfigs = {\n    onedrive_client_id: string\n    redirectUri?: string\n}\n\nexport enum UpupProvider {\n    AWS = 'aws',\n    Azure = 'azure',\n    BackBlaze = 'backblaze',\n    DigitalOcean = 'digitalocean',\n}\n\ntype MaxFileSizeObject = {\n    size: number\n    unit: 'B' | 'KB' | 'MB' | 'GB' | 'TB' | 'PB' | 'EB' | 'ZB' | 'YB'\n}\n\nexport type UpupUploaderPropsClassNames = {\n    fileIcon?: string\n    containerMini?: string\n    containerFull?: string\n    containerHeader?: string\n    containerCancelButton?: string\n    containerAddMoreButton?: string\n\n    adapterButtonList?: string\n    adapterButton?: string\n    adapterButtonIcon?: string\n    adapterButtonText?: string\n\n    adapterViewHeader?: string\n    adapterViewCancelButton?: string\n    adapterView?: string\n    driveLoading?: string\n\n    driveHeader?: string\n    driveLogoutButton?: string\n    driveSearchContainer?: string\n    driveSearchInput?: string\n    driveBody?: string\n    driveItemContainerDefault?: string\n    driveItemContainerSelected?: string\n    driveItemContainerInner?: string\n    driveItemInnerText?: string\n    driveFooter?: string\n    driveAddFilesButton?: string\n    driveCancelFilesButton?: string\n\n    urlInput?: string\n    urlFetchButton?: string\n\n    cameraPreviewContainer?: string\n    cameraDeleteButton?: string\n    cameraCaptureButton?: string\n    cameraRotateButton?: string\n    cameraAddButton?: string\n\n    fileListContainer?: string\n    fileListContainerInnerSingle?: string\n    fileListContainerInnerMultiple?: string\n    fileListFooter?: string\n\n    filePreviewPortal?: string\n    fileItemSingle?: string\n    fileItemMultiple?: string\n    fileThumbnailSingle?: string\n    fileThumbnailMultiple?: string\n    fileInfo?: string\n    fileName?: string\n    fileSize?: string\n    filePreviewButton?: string\n    fileDeleteButton?: string\n\n    uploadButton?: string\n    uploadDoneButton?: string\n\n    progressBarContainer?: string\n    progressBar?: string\n    progressBarInner?: string\n    progressBarText?: string\n}\n\nexport type UpupUploaderPropsIcons = {\n    ContainerAddMoreIcon?: FC<{ className?: string }>\n\n    FileDeleteIcon?: FC<{ className?: string }>\n\n    CameraDeleteIcon?: FC<{ className?: string }>\n    CameraCaptureIcon?: FC<{ className?: string }>\n    CameraRotateIcon?: FC<{ className?: string }>\n\n    LoaderIcon?: FC<{ className?: string }>\n}\n\nexport type UpupUploaderProps = {\n    // Required Props\n    provider: UpupProvider\n    tokenEndpoint: string\n\n    // Optional Props\n    enableAutoCorsConfig?: boolean\n    uploadAdapters?: UploadAdapter[]\n    driveConfigs?: {\n        googleDrive?: GoogleDriveConfigs\n        oneDrive?: OneDriveConfigs\n    }\n    shouldCompress?: boolean\n    accept?: string\n    limit?: number\n    mini?: boolean\n    maxFileSize?: MaxFileSizeObject\n    customProps?: object\n    dark?: boolean\n    classNames?: UpupUploaderPropsClassNames\n    icons?: UpupUploaderPropsIcons\n\n    // Event Handlers\n    onFilesSelected?: (files: File[]) => void\n    onPrepareFiles?: (files: FileWithParams[]) => Promise<FileWithParams[]>\n    onFileClick?: (file: FileWithParams) => void\n    onIntegrationClick?: (integrationType: string) => void\n    onFileUploadStart?: (file: FileWithParams) => void\n    onFileUploadComplete?: (file: FileWithParams, key: string) => void\n    onFilesUploadComplete?: (keys: string[]) => void\n    onFileUploadProgress?: (\n        file: FileWithParams,\n        {\n            loaded,\n            total,\n            percentage,\n        }: { loaded: number; total: number; percentage: number },\n    ) => void\n    onFilesUploadProgress?: (completedFiles: number, totalFiles: number) => void\n    onFileRemove?: (file: FileWithParams) => void\n    onFilesDragOver?: (files: File[]) => void\n    onFilesDragLeave?: (files: File[]) => void\n    onFilesDrop?: (files: File[]) => void\n    onFileTypeMismatch?: (file: File, acceptedTypes: string) => void\n    // onCancelUpload?: (files: FileWithParams[]) => void\n    onError?: (errorMessage: string) => void\n    onWarn?: (warningMessage: string) => void\n}\n\nexport type PresignedUrlResponse = {\n    key: string\n    publicUrl: string\n    uploadUrl: string\n    expiresIn: number\n}\n\nexport enum UploadErrorType {\n    PERMISSION_ERROR = 'PERMISSION_ERROR',\n    EXPIRED_URL = 'EXPIRED_URL',\n\n    FILE_VALIDATION_ERROR = 'FILE_VALIDATION_ERROR',\n    PRESIGNED_URL_ERROR = 'PRESIGNED_URL_ERROR',\n\n    SIGNED_URL_ERROR = 'SIGNED_URL_ERROR',\n    CORS_CONFIG_ERROR = 'CORS_CONFIG_ERROR',\n    TEMPORARY_CREDENTIALS_ERROR = 'TEMPORARY_CREDENTIALS_ERROR',\n\n    UNKNOWN_UPLOAD_ERROR = 'UNKNOWN_UPLOAD_ERROR',\n}\n\nexport class UploadError extends Error {\n    private readonly DEFAULT_ERROR_STATUS_CODE = 500\n\n    constructor(\n        message: string,\n        public type = UploadErrorType.UNKNOWN_UPLOAD_ERROR,\n        public retryable = false,\n        public status?: number,\n    ) {\n        super(message)\n        this.name = 'UploadError'\n        this.status = status ?? this.DEFAULT_ERROR_STATUS_CODE\n    }\n}\n\nexport type FileWithParams = File & { id: string; url: string }\n\nexport type FileWithProgress = FileWithParams & { progress: number }\n","export default function checkFileType(accept: string, file: File) {\n    const fileType = file.type\n    // Return false for invalid inputs\n    if (!accept) return false\n    // Validate fileType has proper MIME format (type/subtype)\n    if (fileType) {\n        const [type, subtype] = fileType.split('/')\n        if (type && subtype) {\n            const acceptedTypes = accept.split(',').map(t => t.trim())\n            const isValidType =\n                acceptedTypes.includes('*') ||\n                acceptedTypes.some(item => {\n                    if (item.includes('/*')) {\n                        const [mainType] = item.split('/')\n                        return fileType.startsWith(mainType)\n                    }\n                    return item.toLowerCase() === fileType.toLowerCase()\n                })\n            if (isValidType) return true\n        }\n    }\n\n    const fileName = file.name ?? ''\n    if (!fileName) {\n        return false\n    }\n\n    const fileExt = fileName.split('.').pop()?.toLowerCase() || ''\n    if (fileExt) {\n        const acceptedTypes = accept.split(',').map(t => t.trim().toLowerCase())\n        const isValidExtension = acceptedTypes.some(ext => {\n            if (ext.startsWith('.')) {\n                return ext.slice(1) === fileExt\n            }\n            return false\n        })\n        if (isValidExtension) return true\n    }\n    return false\n}\n","import checkFileType from '../../../shared/lib/checkFileType'\nimport { UploadError, UploadErrorType } from '../../../shared/types'\nimport { FileParams } from '../../types'\n\nconst DEFAULT_MAX_FILE_SIZE = 10 * 1024 * 1024 // 10MB;\n\nexport default function fileValidateParams(file: FileParams) {\n    // Validate required file params\n    const requiredFileParams = ['name', 'type', 'size'] as const\n    const missing = requiredFileParams.filter(key => !file[key])\n    if (missing.length > 0)\n        throw new UploadError(\n            `Missing required file param: ${missing.join(', ')}`,\n            UploadErrorType.FILE_VALIDATION_ERROR,\n            false,\n            400,\n        )\n\n    const {\n        type: fileType,\n        accept = '*',\n        size,\n        maxFileSize = DEFAULT_MAX_FILE_SIZE,\n    } = file\n\n    // Validate file type against accept pattern\n    if (!checkFileType(accept, file as File))\n        throw new UploadError(\n            `File type ${fileType} not allowed. Accepted types: ${accept}`,\n            UploadErrorType.FILE_VALIDATION_ERROR,\n            false,\n            400,\n        )\n\n    // Validate file size\n    if (size > maxFileSize)\n        throw new UploadError(\n            `File size: ${size} exceeds maximum limit of ${\n                maxFileSize / (1024 * 1024)\n            }MB`,\n            UploadErrorType.FILE_VALIDATION_ERROR,\n            false,\n            413,\n        )\n}\n","import { GetObjectCommand, S3Client, S3ClientConfig } from '@aws-sdk/client-s3'\nimport { getSignedUrl } from '@aws-sdk/s3-request-presigner'\nimport { UploadError, UploadErrorType } from '../../../../shared/types'\n\nconst DEFAULT_URL_VALID_TIME = 3600 * 24 * 3 // 3 days\n\nexport default async function s3GenerateSignedUrl(\n    s3ClientConfig: S3ClientConfig,\n    Key: string,\n    Bucket: string,\n    expiresIn = DEFAULT_URL_VALID_TIME,\n) {\n    try {\n        const s3Client = new S3Client(s3ClientConfig)\n        const url = await getSignedUrl(\n            s3Client,\n            new GetObjectCommand({\n                Bucket,\n                Key,\n            }),\n            {\n                expiresIn,\n            },\n        )\n\n        return url\n    } catch (error) {\n        throw new UploadError(\n            (error as Error).message,\n            UploadErrorType.SIGNED_URL_ERROR,\n            false,\n        )\n    }\n}\n","import { S3ClientConfig } from '@aws-sdk/client-s3'\nimport { createHash, createHmac } from 'crypto'\nimport { UpupProvider } from '../../../shared/types'\n\nfunction hmac(key: string | Buffer, message: string) {\n    return createHmac('sha256', key).update(message).digest()\n}\n\nfunction hash(message: string) {\n    return createHash('sha256').update(message).digest('hex')\n}\n\nfunction getSignatureKey(\n    key: string,\n    dateStamp: string,\n    region: string,\n    service: string,\n) {\n    const kDate = hmac(`AWS4${key}`, dateStamp)\n    const kRegion = hmac(kDate, region)\n    const kService = hmac(kRegion, service)\n    const kSigning = hmac(kService, 'aws4_request')\n    return kSigning\n}\n\nfunction calculateMD5(content: string) {\n    return createHash('md5').update(content).digest('base64')\n}\n\nfunction getHost(\n    bucketName: string,\n    provider: UpupProvider,\n    { endpoint, region }: Pick<S3ClientConfig, 'endpoint' | 'region'>,\n) {\n    switch (provider) {\n        case UpupProvider.AWS:\n            return `${bucketName}.s3.${region}.amazonaws.com`\n        case UpupProvider.BackBlaze:\n            return (endpoint as string).split('https://')[1]\n        case UpupProvider.DigitalOcean:\n            return `${bucketName}.${region}.digitaloceanspaces.com`\n        default:\n            return ''\n    }\n}\n\nexport default function awsGenerateSignatureHeaders(\n    corsConfig: string,\n    bucketName: string,\n    {\n        region,\n        credentials: { accessKeyId, secretAccessKey },\n        endpoint,\n    }: S3ClientConfig & {\n        credentials?: any\n    },\n    provider: UpupProvider,\n) {\n    const service = 's3'\n    const host = getHost(bucketName, provider, { endpoint, region })\n\n    // Calculate Content-MD5\n    const contentMD5 = calculateMD5(corsConfig)\n\n    // Step 1: Create date strings\n    const date = new Date()\n    const amzDate = date.toISOString().replace(/[:-]|\\.\\d{3}/g, '')\n    const dateStamp = amzDate.slice(0, 8)\n\n    // Step 2: Create canonical request\n    const method = 'PUT'\n\n    const canonicalUriMap = {\n        [UpupProvider.AWS]: '/',\n        [UpupProvider.BackBlaze]: `/${bucketName}/`,\n        [UpupProvider.DigitalOcean]: `/`,\n        [UpupProvider.Azure]: ``,\n    }\n    const canonicalUri = canonicalUriMap[provider]\n\n    const canonicalQueryStringMap = {\n        [UpupProvider.AWS]: 'cors=',\n        [UpupProvider.BackBlaze]: 'cors=null',\n        [UpupProvider.DigitalOcean]: 'cors=',\n        [UpupProvider.Azure]: ``,\n    }\n    const canonicalQueryString = canonicalQueryStringMap[provider]\n\n    const payloadHash = hash(corsConfig)\n\n    const canonicalHeaders =\n        `content-md5:${contentMD5}\\n` +\n        `content-type:application/xml\\n` +\n        `host:${host}\\n` +\n        `x-amz-content-sha256:${payloadHash}\\n` +\n        `x-amz-date:${amzDate}\\n`\n\n    const signedHeaders =\n        'content-md5;content-type;host;x-amz-content-sha256;x-amz-date'\n\n    const canonicalRequest = [\n        method,\n        canonicalUri,\n        canonicalQueryString,\n        canonicalHeaders,\n        signedHeaders,\n        payloadHash,\n    ].join('\\n')\n\n    // Step 3: Create string to sign\n    const algorithm = 'AWS4-HMAC-SHA256'\n    const credentialScope = `${dateStamp}/${region}/${service}/aws4_request`\n    const stringToSign = [\n        algorithm,\n        amzDate,\n        credentialScope,\n        hash(canonicalRequest),\n    ].join('\\n')\n\n    // Step 4: Calculate signature\n    const signingKey = getSignatureKey(\n        secretAccessKey,\n        dateStamp,\n        region as string,\n        service,\n    )\n    const signature = createHmac('sha256', signingKey)\n        .update(stringToSign)\n        .digest('hex')\n\n    // Step 5: Create authorization header\n    const authorizationHeader =\n        `${algorithm} ` +\n        `Credential=${accessKeyId}/${credentialScope}, ` +\n        `SignedHeaders=${signedHeaders}, ` +\n        `Signature=${signature}`\n\n    return {\n        'Content-Type': 'application/xml',\n        'Content-MD5': contentMD5, // Added Content-MD5 header\n        Authorization: authorizationHeader,\n        'x-amz-content-sha256': payloadHash,\n        'x-amz-date': amzDate,\n        Host: host,\n    }\n}\n","import { S3ClientConfig } from '@aws-sdk/client-s3'\nimport {\n    UploadError,\n    UploadErrorType,\n    UpupProvider,\n} from '../../../../shared/types'\nimport awsGenerateSignatureHeaders from '../aws-generate-signature-headers'\n\nexport default async function s3UpdateCORS(\n    origin: string,\n    bucketName: string,\n    config: S3ClientConfig,\n    provider: UpupProvider,\n) {\n    const urlMap = {\n        [UpupProvider.AWS]: `https://${bucketName}.s3.${config.region}.amazonaws.com/?cors`,\n        [UpupProvider.BackBlaze]: `${config.endpoint}/${bucketName}/?cors=null`,\n        [UpupProvider.DigitalOcean]: `https://${bucketName}.${config.region}.digitaloceanspaces.com/?cors`,\n        [UpupProvider.Azure]: ``,\n    }\n    const url = urlMap[provider]\n\n    const corsConfig = `<?xml version=\"1.0\" encoding=\"UTF-8\"?><CORSConfiguration>\n    <CORSRule>\n        <ID>Allow S3 Operations from my site: ${origin}</ID>\n        <AllowedOrigin>${origin}</AllowedOrigin>\n        <AllowedHeader>*</AllowedHeader>\n        <AllowedMethod>HEAD</AllowedMethod>\n        <AllowedMethod>PUT</AllowedMethod>\n        <AllowedMethod>GET</AllowedMethod>\n        <AllowedMethod>POST</AllowedMethod>\n        <ExposeHeader>ETag</ExposeHeader>\n        <MaxAgeSeconds>3600</MaxAgeSeconds>\n    </CORSRule>\n</CORSConfiguration>`\n\n    const headers = awsGenerateSignatureHeaders(\n        corsConfig,\n        bucketName,\n        config,\n        provider,\n    )\n\n    const response = await fetch(url, {\n        method: 'PUT',\n        body: corsConfig,\n        headers,\n    })\n\n    if (!response.ok) {\n        const errorText = await response.text()\n        throw new UploadError(\n            errorText,\n            UploadErrorType.CORS_CONFIG_ERROR,\n            false,\n            response.status,\n        )\n    }\n\n    const data = await response.text()\n    return data\n}\n","import { ClientSecretCredential } from '@azure/identity'\nimport {\n    BlobSASPermissions,\n    BlobServiceClient,\n    SASProtocol,\n    generateBlobSASQueryParameters,\n} from '@azure/storage-blob'\nimport { v4 as uuid } from 'uuid'\nimport {\n    PresignedUrlResponse,\n    UploadError,\n    UploadErrorType,\n} from '../../../shared/types'\nimport { AzureSasUrlParams } from '../../types'\nimport fileValidateParams from '../files/file-validate-params'\nimport azureGetTemporaryCredentials from './azure-get-temporary-credentials'\n\nexport default async function azureGenerateSasUrl({\n    fileParams,\n    containerName,\n    credentials,\n    expiresIn = 3600,\n}: AzureSasUrlParams): Promise<PresignedUrlResponse> {\n    try {\n        // Validate file params\n        fileValidateParams(fileParams)\n\n        // Create Azure AD credentials\n        const credential = new ClientSecretCredential(\n            credentials.tenantId,\n            credentials.clientId,\n            credentials.clientSecret,\n        )\n\n        // Create blob service client\n        const blobServiceClient = new BlobServiceClient(\n            `https://${credentials.storageAccount}.blob.core.windows.net`,\n            credential,\n        )\n\n        // Get user delegation key\n        const userDelegationKey =\n            await azureGetTemporaryCredentials(blobServiceClient)\n\n        const { name: fileName, type: contentType } = fileParams\n        const blobName = `${uuid()}-${fileName}`\n\n        // Get container client\n        const containerClient =\n            blobServiceClient.getContainerClient(containerName)\n\n        // Get blob client\n        const blobClient = containerClient.getBlobClient(blobName)\n\n        // Generate SAS token\n        const sasToken = generateBlobSASQueryParameters(\n            {\n                containerName,\n                blobName,\n                permissions: BlobSASPermissions.parse('racw'),\n                startsOn: new Date(),\n                expiresOn: new Date(Date.now() + expiresIn * 1000),\n                protocol: SASProtocol.Https,\n                contentType,\n            },\n            userDelegationKey,\n            credentials.storageAccount,\n        ).toString()\n\n        // Construct full URL\n        const uploadUrl = `${blobClient.url}?${sasToken}`\n\n        return {\n            key: blobName,\n            publicUrl: blobClient.url,\n            uploadUrl,\n            expiresIn,\n        }\n    } catch (error) {\n        if (error instanceof UploadError) throw error\n\n        throw new UploadError(\n            (error as Error).message,\n            UploadErrorType.PRESIGNED_URL_ERROR,\n            false,\n            500,\n        )\n    }\n}\n","import { BlobServiceClient } from '@azure/storage-blob'\nimport { UploadError, UploadErrorType } from '../../../shared/types'\n\nexport default async function azureGetTemporaryCredentials(\n    blobServiceClient: BlobServiceClient,\n    expiresIn = 3600,\n) {\n    try {\n        // Get start and end time for delegation key\n        const startsOn = new Date()\n        const expiresOn = new Date(startsOn)\n        expiresOn.setMinutes(startsOn.getMinutes() + expiresIn / 60) // 1 hour validity\n\n        // Get user delegation key\n        const userDelegationKey = await blobServiceClient.getUserDelegationKey(\n            startsOn,\n            expiresOn,\n        )\n\n        return userDelegationKey\n    } catch (error) {\n        throw new UploadError(\n            (error as Error).message,\n            UploadErrorType.TEMPORARY_CREDENTIALS_ERROR,\n            false,\n            500,\n        )\n    }\n}\n"],"mappings":"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","names":["index_node_exports","__export","UpupProvider","azureGenerateSasUrl","s3GeneratePresignedUrl","s3GenerateSignedUrl","__toCommonJS","import_client_s3","import_s3_request_presigner","import_uuid","UpupProvider","UploadError","message","type","retryable","status","checkFileType","accept","file","_a","fileType","type","subtype","acceptedTypes","t","item","mainType","fileName","fileExt","ext","DEFAULT_MAX_FILE_SIZE","fileValidateParams","file","missing","key","UploadError","fileType","accept","size","maxFileSize","checkFileType","import_client_s3","import_s3_request_presigner","DEFAULT_URL_VALID_TIME","s3GenerateSignedUrl","s3ClientConfig","Key","Bucket","expiresIn","s3Client","error","UploadError","import_crypto","hmac","key","message","hash","getSignatureKey","dateStamp","region","service","kDate","kRegion","kService","calculateMD5","content","getHost","bucketName","provider","endpoint","awsGenerateSignatureHeaders","corsConfig","accessKeyId","secretAccessKey","host","contentMD5","amzDate","method","canonicalUri","canonicalQueryString","payloadHash","canonicalHeaders","signedHeaders","canonicalRequest","algorithm","credentialScope","stringToSign","signingKey","signature","authorizationHeader","s3UpdateCORS","origin","bucketName","config","provider","url","corsConfig","headers","awsGenerateSignatureHeaders","response","errorText","UploadError","DEFAULT_EXPIRES_IN","getUploadErrorParams","error","message","errorType","s3GeneratePresignedUrl","fileParams","Bucket","s3ClientConfig","expiresIn","origin","provider","enableAutoCorsConfig","fileName","ContentType","ContentLength","fileValidateParams","s3UpdateCORS","client","Key","uuid","command","uploadUrl","publicUrl","s3GenerateSignedUrl","UploadError","import_identity","import_storage_blob","import_uuid","azureGetTemporaryCredentials","blobServiceClient","expiresIn","startsOn","expiresOn","error","UploadError","azureGenerateSasUrl","fileParams","containerName","credentials","expiresIn","fileValidateParams","credential","blobServiceClient","userDelegationKey","azureGetTemporaryCredentials","fileName","contentType","blobName","uuid","blobClient","sasToken","uploadUrl","error","UploadError"]}